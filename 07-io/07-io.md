# Streamek #
Csatornák, absztrakciós szint bemenet-kimenet kezelésére (`hiext`, `lorem`).

> **Részletesen:** <http://java.sun.com/docs/books/tutorial/essential/io/>

## Példa ##
	package io;
	
	import java.io.FileWriter;
	import java.io.PrintWriter;
	
	public class WriteSampleFile {
	    public static void main(String[] args) throws Exception {
	        PrintWriter pw = new PrintWriter( new FileWriter("dummy.txt") );
	        pw.println("Dummy data here");
	        pw.close();
	    }
	}

## Csoportosítás ##

Szervezés szerint:
\begin{itemize}
\item InputStream, OutputStream (bájtszervezésű)
\item Reader, Writer (karakterszervezésű)
\end{itemize}

Ezekből rengeteg változat, pl.
\begin{itemize}
\item StringReader, FileReader, BufferedReader, etc.
\item FileInputStream, DataInputStream, etc.
\item FileOutputStream, PrintStream, etc.
\item FileWriter, PrintWriter, etc.
\end{itemize}

Pl. FileReader, FileWriter, FileInputStream, FileOutputStream

Feladat szerinti csoportosítás:
\begin{itemize}
\item Adatforrás, adatnyelő (pl. FileInputStream, FileReader)
\item Szűrők: meglévő csatornához plusz funkcionalitás (pl. BufferedInputStream). Összekapcsolhatók (pl. SequenceInputStream), csatornák hozhatók létre (pl. kommunikációs közeg szálaknak, PipedInputStream, etc.)
\end{itemize}

\subsection*{Alapvető műveletek}
\begin{itemize}
\item Megnyitás automatikus, lezárás: \texttt{close()} (ne felejtsd el, mert nem fogsz tudni hozzáférni)
\item flush(): automatikus endline karakterre a szöveges fájlokban.
\item Kiírás: write(), print()
\item Olvasás: read(). Ha a csatorna kiürül, akkor az olvasó művelet blokkolódik, amíg adatot nem kap:

\begin{verbatim}
public static void main(String[] args) throws Exception {
    int i = System.in.read();
    System.out.println("A kapott karakter: " + i);
}
\end{verbatim}

\item "Könyvjelző-mechanizmus", ha támogatott: markSupported(), mark(), reset()
\item Padding átugrása: skip()
\item Csatorna ürességének ellenőrzése: ready()
\item Hány bájtot lehet minimum olvasni? available()
\begin{verbatim}
int meret = new FileInputStream("tmp.txt").available();
\end{verbatim}
\end{itemize}

\subsection*{Speciális streamek}

\begin{enumerate}
\item Sorok számolására: LineNumberInputStream\#getLineNumber()
\item Adatok olvasása, visszafűzése a csatornára: PushbackInputStream, PushbackReader
\item Bufferelt csatornák: BufferedReader, BufferedInputStream
\item Véletlen elérésű fájlok: RandomAccessFile
\item Szövegfeldolgozás: StringTokenizer (van sima StreamTokenizer is)
\item System.in, out, err: InputStream ill. PrintStream-ek. Pl. std. input átirányítása:
\begin{verbatim}
BufferedReader br = new BufferedReader(
    new InputStreamReader(System.in) );
\end{verbatim}
\end{enumerate}

\bigskip
\noindent
\textbf{Részletesen:} \url{http://download.oracle.com/javase/6/docs/api/java/io/package-summary.html}

\subsection*{Példák}
\subsubsection*{Fájl írása}

\begin{verbatim}
package files;

import java.io.FileNotFoundException;
import java.io.PrintWriter;

public class WriteFile {
    public static void main(String[] args) {
        PrintWriter pw = null;
        
        try {
            pw = new PrintWriter(args[0]);
            
            pw.println("Line1");
            pw.println("Line2");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            if (pw != null) pw.close();
        }
    }
}
\end{verbatim}

\newpage
\subsubsection*{Fájl olvasása}
\begin{verbatim}
package files;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class ReadFile {
    public static void main(String[] args) {
        BufferedReader br = null;
        
        try {
            br = new BufferedReader(new FileReader(args[0]));
            String line = null;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (br != null) {
                try {
                  br.close();
                } catch (IOException e) {
                  e.printStackTrace(); 
                }
            }
        }
    }
}
\end{verbatim}

\newpage
\section*{Feladatok}
\begin{itemize}
\item Készíts egy szűrő programot, amely két parancssori argumentumot kap: egy input fájl elérési utat, és egy stringet! A program olvassa be az inputfájlt, és írja ki a képernyőre azokat a sorokat, amelyekben a megadott karakterlánc előfordul!

\item Készíts egy programot, amely két parancssori argumentumot kap: egy input fájl elérési utat, és egy stringet! A program olvassa be az inputfájlt, és számolja meg a megadott szó előfordulásainak számát!

\item Készíts egy interaktív programot, amely a felhasználó által megadott sorokat (egészen az üres sorig) elmenti egy fájlba. Az output fájl nevét kérje be a program indulásnál.

\item Készíts egy programot, amely egy parancssori argumentumként megadott fájlnak kiírja az első $N$ sorát ($N=5$ alapértelmezett értékkel rendelkezik, azonban opcionális  parancssori argumentummal ezt állítani lehessen).

\item Készíts egy programot, amely egy parancssori argumentumként megadott fájlnak kiírja az utolsó $N$ sorát ($N=5$ alapértelmezett értékkel rendelkezik, azonban opcionális  parancssori argumentummal ezt állítani lehessen).

\item Készíts egy programot, amely három parancssori argumentumot kap: két input fájl és egy output fájl elérési utat. A program fűzze össze az első két fájlt egymás után az output fájlba!

\item Adott egy fájl a következő szerkezettel:

\begin{verbatim}
# Comment sor
# Ezeket at kell ugrani
# A file formatuma:
# <Nev>:<Szuletesi ev>:<honap>:<nap>
Citad Ella:1984:10:10
Har Monika:1956:5:6
Git Aron:1992:11:23
Tek Elek:2002:6:14
\end{verbatim}

A program olvassa be ezeket az adatokat, és tárolja egy megfelelő reprezentációban (készíts pl. egy \texttt{Person} osztályt a szükséges adattagokkal). A program parancssori argumentumként kapjon egy hónapot, és listázza ki, hogy az adott hónapban mely személyeknek van születésnapja. Használjátok a String osztály split() metódusát.

\item Készíts egy programot, amely kiírja egy parancssori argumentumként megadott fájl páratlan sorait a képernyőre, páros sorait pedig egy \textit{"even.txt"} fájlba! Ezután a \textit{"even.txt"} tartalmával felülírja az eredeti fájlt.

\item Készítsünk egy egyszerű l33t5p34k (leetspeak) generátort! A program 1 parancssori argumentumot kapjon: egy input fájl elérési utat. A program olvassa be az input fájlt, és minden szón végezze el a következő módosításokat, majd írja ki a képernyőre a módosított szöveget:

\begin{itemize}
\item Ha a szó vége:
	\begin{itemize}
	\item "s" $\rightarrow$ "z"
	\item "ck" $\rightarrow$ "x"
	\end{itemize}
\item "a" $\rightarrow$ "@"
\item "e" $\rightarrow$ "3"
\item "i" $\rightarrow$ "1"
\item "o" $\rightarrow$ "0"
\item "u" $\rightarrow$ "v"
\item "f" $\rightarrow$ "ph"
\item "s" $\rightarrow$ "\$"
\item "g" $\rightarrow$ "9"
\item "y" $\rightarrow$ "j"
\item "t" $\rightarrow$ "+"
\item "!" $\rightarrow$ "1"
\item Ezen kívül minden 2. karakter esetén a kisbetűből csináljon nagyot, a nagybetűből kicsit!
\end{itemize}

\end{itemize}

\end{document}
